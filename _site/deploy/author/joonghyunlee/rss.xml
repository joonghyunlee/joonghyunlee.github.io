<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>joonghyunlee.github.io</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Windows Terminal</title>
	  <link>//windows-terminal</link>
	  <author></author>
	  <pubDate>2020-01-31T18:00:00-06:00</pubDate>
	  <guid>//windows-terminal</guid>
	  <description><![CDATA[
	     <p>Terminal은 MicroSoft에서 기존 명령 프롬프트 및 PowerShell 터미널을 대체하고자 새로 출시한 터미널 프로그램이다.
기존 내장 터미널은 기능적이나 미적으로나 Mac/Linux 용 터미널에 비해 매우 떨어져 있던 것이 사실이다.
이에 반해 Terminal은 최신 터미널 프로그램에서 제공하는 다양한 기능을 제공할 뿐만 아니라 WSL까지도 지원하여 보다 나은 개발 환경을 제공한다.
개인적으로 WSL을 사용하면서 폰트 설정이나 개인화 설정이 불편을 겪었던 기억이 있어서, Terminal을 적극적으로 활용해보려고 노력해보았다.</p>

<h2 id="설치-방법">설치 방법</h2>

<p>Terminal 앱 설치 방법은 간단하다. MS 스토어에서 <code class="highlighter-rouge">Windows Terminal</code>을 검색하여 내려받자.</p>

<p><img src="assets/images/utilities/Terminal00.png" alt="Windows%20Terminal/Untitled.png" /></p>

<h2 id="기본-프로파일-변경">기본 프로파일 변경</h2>

<p>Windows Terminal은 프로파일별로 원하는 Shell을 등록할 수 있게 되어 있다. 기본적으로 등록된 프로파일에는 <strong>Windows PowerShell</strong>, <strong>Command Prompt</strong>, <strong>WSL</strong> 등이 있다.</p>

<p>여기서는 WSL 프로파일을 기본으로 하도록 설정을 바꿔보자. Windows Terminal을 실행한 후 설정을 열자. 단축키 <code class="highlighter-rouge">Ctrl + ,</code>을 누르거나 상단 메뉴를 선택하여 설정을 열자.</p>

<p><img src="assets/images/utilities/Terminal01.png" alt="Windows%20Terminal/Untitled%201.png" /></p>

<p>그러면 아래와 같이 메모장이 열리면서 설정 파일이 나타난다.</p>

<p><img src="assets/images/utilities/Terminal02.png" alt="Windows%20Terminal/Untitled%202.png" /></p>

<p>이 설정에 대한 기본 포맷은 설정파일 상단의 링크(<a href="https://aka.ms/terminal-profiles-schema">https://aka.ms/terminal-profiles-schema</a>)를 참조하자.</p>

<p>설정의 <code class="highlighter-rouge">profiles</code> 필드에 등록된 프로파일에 대한 설정들이 나와 있다. 이 프로파일들 중 WSL에 해당하는 프로파일을 찾아서 <code class="highlighter-rouge">guid</code> 값을 확인한다. 이 값을 <code class="highlighter-rouge">defaultProfile</code>에 설정한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"defaultProfile"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"profiles"</span><span class="p">:</span><span class="w">
    </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="s2">"guid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"hidden"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu-18.04"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Windows.Terminal.Wsl"</span><span class="w">
        </span><span class="p">},</span><span class="w">
    </span><span class="p">],</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>수정한 설정을 반영하려면 <code class="highlighter-rouge">Ctrl + s</code>를 눌러 저장하면 된다.</p>

<h2 id="시작-폴더-변경">시작 폴더 변경</h2>

<p>WSL 프로파일을 처음 시작해보면 시작 폴더가 Window의 사용자 홈 폴더(<code class="highlighter-rouge">%userprofile%</code>)로 되어 있다. 매번 WSL 사용자의 홈 폴더로 이동하기는 번거로우므로 시작하자마 WSL 사용자 홈 폴더로 이동하도록 해보자. 아래와 같이 WSL 프로파일에 <code class="highlighter-rouge">commandline</code> 속성을 추가한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"guid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"hidden"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"commandline"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wsl ~"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu-18.04"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Windows.Terminal.Wsl"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<h2 id="프로파일-아이콘-변경">프로파일 아이콘 변경</h2>

<p>이제 기본적인 설정은 끝났다. 다 좋은데 이상하게 WSL 프로파일 탭을 열면 아이콘이 펭귄으로 되어 있다. Linux의 상징이라 잘 못된 것은 아니지만 개인적으로는 무척 별로다.</p>

<p><img src="assets/images/utilities/Terminal03.png" alt="Windows%20Terminal/Untitled%203.png" /></p>

<p>이 아이콘을 Ubuntu 아이콘으로 변경해보자. 아이콘을 변경하려면 우선 Terminal이 읽을 수 있는 폴더에 아이콘을 복사해 두어야 한다. 특정 위치에 있는 폴더를 지정해도 좋지만 여기서는 Terminal의 AppData 폴더로 아이콘을 옮겨보자. Terminal의 AppData 폴더는 아래와 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\RoamingState
</code></pre></div></div>
<p>위의 경로로 이동하려면 Windows의 탐색기 경로 바에 입력하면 된다. 그럼 해당 위치로 이동할 수 있다.</p>

<p><img src="assets/images/utilities/Terminal04.png" alt="Windows%20Terminal/Untitled%204.png" /></p>

<p>이 폴더에 대체할 아이콘을 복사해두자. 여기서는 아래 이미지를 사용하였다.</p>

<p><img src="assets/images/utilities/ubuntu.png" alt="Windows%20Terminal/ubuntu.png" /></p>

<p>이제 WSL 프로파일에 다음과 같이 <code class="highlighter-rouge">icon</code> 항목을 추가하자. 저장하면 탭 아이콘이 변경될 것이다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"guid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"hidden"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"commandline"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wsl ~"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu-18.04"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"icon"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ms-appdata:///roaming/ubuntu.png"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Windows.Terminal.Wsl"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<h2 id="탭-이름-변경">탭 이름 변경</h2>

<p>아무런 설정을 하지 않으면 탭 이름이 프롬프트 명을 따라 간다. 만약 현재 경로가 길어지면 잘려서 보이는 문제가 있다.</p>

<p><img src="assets/images/utilities/Terminal05.png" alt="Windows%20Terminal/Untitled%205.png" /></p>

<p>역시 개인적인 취향으로는 차라리 고정 문구가 나오는 편이 좋을 것 같다. 여기서는 <strong>Ubuntu</strong>라고 출력하도록 하자. Ubuntu 파일에 다음 두 항목을 추가한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"tabTitle"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"suppressApplicationTitle"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>저장하면 다음과 같이 반영된다. <del>편안</del></p>

<p><img src="assets/images/utilities/Terminal06.png" alt="Windows%20Terminal/Untitled%206.png" /></p>

<h2 id="처음-화면-크기-변경">처음 화면 크기 변경</h2>

<p>최초 구동할 때 화면의 크기를 설정하고 싶다면 아래와 같이 설정한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"$schema"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://aka.ms/terminal-profiles-schema"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"globals"</span><span class="w"> </span><span class="p">:</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="s2">"initialCols"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">120</span><span class="p">,</span><span class="w">
        </span><span class="s2">"initialRows"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="w">
        </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<h2 id="단축키-설정">단축키 설정</h2>

<p>키 설정은 <code class="highlighter-rouge">keybindings</code> 필드에 등록하면 된다. 우선 탭 관리에 관한 단축키를 알아보자.</p>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ctrl + shift + t</td>
      <td>새 탭 열기</td>
    </tr>
    <tr>
      <td>ctrl + shift + [1-8]</td>
      <td>n번 째 프로파일 탭 열기</td>
    </tr>
    <tr>
      <td>ctrl + shift + w</td>
      <td>탭 닫기</td>
    </tr>
    <tr>
      <td>ctrl + tab</td>
      <td>다음 탭으로 이동</td>
    </tr>
    <tr>
      <td>ctrl + shift + tab</td>
      <td>이전 탭으로 이동</td>
    </tr>
    <tr>
      <td>ctrl + alt + [1-8]</td>
      <td>n번 째 탭으로 이동</td>
    </tr>
    <tr>
      <td>ctrl + shift + space</td>
      <td>탭 메뉴 열기</td>
    </tr>
    <tr>
      <td>ctrl + shift + d</td>
      <td>현재 탭 복제하기</td>
    </tr>
  </tbody>
</table>

<p>위 단축키들은 아래와 같이 등록된다. 같은 기능에 대한 단축키들은 여러 개 등록할 수 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"keybindings" :
  [
      {
          "command" : "closePane",
          "keys" :
          [
              "ctrl+shift+w"
          ]
      }
]
</code></pre></div></div>
<p>다음으로는 0.7 버전부터 추가된 Pane에 대한 단축키를 알아보자.</p>

<table>
  <thead>
    <tr>
      <th>단축키</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>alt + shift + <code class="highlighter-rouge">-</code></td>
      <td>화면 수평 분할</td>
    </tr>
    <tr>
      <td>alt + shift + <code class="highlighter-rouge">+</code></td>
      <td>화면 수직 분할</td>
    </tr>
    <tr>
      <td>alt + down</td>
      <td>포커스 아래로 이동</td>
    </tr>
    <tr>
      <td>alt + left</td>
      <td>포커스 왼쪽으로 이동</td>
    </tr>
    <tr>
      <td>alt + right</td>
      <td>포커스 오른쪽으로 이동</td>
    </tr>
    <tr>
      <td>alt + up</td>
      <td>포커스 위로 이동</td>
    </tr>
    <tr>
      <td>alt + shift + down</td>
      <td>화면 크기 아래로 늘리기</td>
    </tr>
    <tr>
      <td>alt + shift + left</td>
      <td>화면 크기 왼쪽으로 늘리기</td>
    </tr>
    <tr>
      <td>alt + shift + right</td>
      <td>화면 크기 오른쪽으로 늘리기</td>
    </tr>
    <tr>
      <td>alt + shift + up</td>
      <td>화면 크기 위로 늘리기</td>
    </tr>
  </tbody>
</table>

<h2 id="테마-변경">테마 변경</h2>

<p>마지막으로 테마 변경을 해보자. 기본적으로 제공하는 테마는 아래와 같다.</p>

<ul>
  <li>Campbell</li>
  <li>One Half Dark</li>
  <li>One Half Light</li>
  <li>Solarized Dark</li>
  <li>Solarized Light</li>
</ul>

<p>당연하게도 커스텀한 테마를 생성할 수도 있다. 커스텀 테마를 생성하려면 <code class="highlighter-rouge">schemes</code> 항목에 다음과 같이 추가해준다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"schemes"</span><span class="w"> </span><span class="p">:</span><span class="w">
    </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="s2">"background"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#0C0C0C"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"black"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#0C0C0C"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"blue"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#0037DA"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightBlack"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#767676"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightBlue"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#3B78FF"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightCyan"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#61D6D6"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightGreen"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#16C60C"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightPurple"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#B4009E"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightRed"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#E74856"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightWhite"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#F2F2F2"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"brightYellow"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#F9F1A5"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"cyan"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#3A96DD"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"foreground"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#CCCCCC"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"green"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#13A10E"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"name"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Campbell"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"purple"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#881798"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"red"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#C50F1F"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"white"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#CCCCCC"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"yellow"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"#C19C00"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>또한 아래와 같이 설정할 수 도 있다. 이 때 <code class="highlighter-rouge">colors</code> 배열의 순서는 <strong>black</strong>, <strong>red</strong>, <strong>green</strong>, <strong>yellow</strong>, <strong>blue</strong>, <strong>magenta</strong>, <strong>cyan</strong>, <strong>white</strong>, <strong>bright black</strong>, <strong>bright red</strong>, <strong>bright green</strong>, <strong>bright yellow</strong>, <strong>bright blue</strong>, <strong>bright magenta</strong>, <strong>bright cyan</strong>, <strong>bright white</strong> 이다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"schemes"</span><span class="w"> </span><span class="p">:</span><span class="w">
    </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"UbuntuLegit"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"foreground"</span><span class="p">:</span><span class="w"> </span><span class="s2">"#EEEEEE"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"background"</span><span class="p">:</span><span class="w"> </span><span class="s2">"#2C001E"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"colors"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
              </span><span class="s2">"#4E9A06"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#CC0000"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#300A24"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#C4A000"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#3465A4"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#75507B"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#06989A"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#D3D7CF"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#555753"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#EF2929"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#8AE234"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#FCE94F"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#729FCF"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#AD7FA8"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#34E2E2"</span><span class="p">,</span><span class="w">
              </span><span class="s2">"#EEEEEE"</span><span class="w">
          </span><span class="p">]</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>테마를 적용하려면 프로파일에 아래와 같이 <code class="highlighter-rouge">colorScheme</code> 항목을 추가한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"profiles"</span><span class="p">:</span><span class="w">
    </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="s2">"guid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"hidden"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="s2">"commandline"</span><span class="p">:</span><span class="w"> </span><span class="s2">"wsl ~"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu-18.04"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"colorScheme"</span><span class="p">:</span><span class="w"> </span><span class="s2">"UbuntuLegit"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"icon"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ms-appdata:///roaming/ubuntu.png"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"tabTitle"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Ubuntu"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"suppressApplicationTitle"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
            </span><span class="s2">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Windows.Terminal.Wsl"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>테마 색상 설정을 확인하려면 아래의 스크립트를 실행하자.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nv">COLORS</span><span class="o">=(</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[30mBlack"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[31mRed"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[32mGreen"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[33mYellow"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[34mBlue"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[35mMagenta"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[36mCyan"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[37mWhite"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[90mBright Black"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[91mBright Red"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[92mBright Green"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[93mBright Yellow"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[94mBright Blue"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[95mBright Magenta"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[96mBright Cyan"</span>
<span class="s2">"</span><span class="se">\e</span><span class="s2">[97mBright White"</span>
<span class="o">)</span>

<span class="k">for</span> <span class="o">((</span>i <span class="o">=</span> 0<span class="p">;</span> i &lt; <span class="k">${#</span><span class="nv">COLORS</span><span class="p">[@]</span><span class="k">}</span><span class="p">;</span> i++<span class="o">))</span>
<span class="k">do
    </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="k">${</span><span class="nv">COLORS</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span>
<span class="k">done</span>
</code></pre></div></div>
<p>위 스크립트 실행 결과는 다음과 같다.</p>

<p><img src="assets/images/utilities/Terminal07.png" alt="Windows%20Terminal/Untitled%207.png" /></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://aka.ms/terminal-profiles-schema">https://aka.ms/terminal-profiles-schema</a></li>
  <li><a href="https://www.howtogeek.com/426346/how-to-customize-the-new-windows-terminal-app/">https://www.howtogeek.com/426346/how-to-customize-the-new-windows-terminal-app/</a></li>
  <li><a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-7-release/">https://devblogs.microsoft.com/commandline/windows-terminal-preview-v0-7-release/</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Tox: Python Test Automation Framework</title>
	  <link>//tox</link>
	  <author></author>
	  <pubDate>2020-01-31T18:00:00-06:00</pubDate>
	  <guid>//tox</guid>
	  <description><![CDATA[
	     <p>Tox는 Python 프로젝트에 대한 테스트 자동화를 지원해주는 도구이다. Python 2 또는 3 등 다양한 환경에서의 테스트를 지원하고자 <code class="highlighter-rouge">virtualenv</code>를 기반으로 테스트 환경을 구성하고, 사전에 지정한 대로 테스트를 진행할 수 있게끔 해준다. Tox는 아래와 같이 <code class="highlighter-rouge">tox.ini</code>파일을 기반으로 설정하게 된다.</p>

<ul>
  <li><code class="highlighter-rouge">tox.ini</code></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># content of: tox.ini , put in same dir as setup.py
[tox]
envlist = py27,py36

[testenv]
# install testing framework
# ... or install anything else you might need here
deps = pytest
# run the tests
# ... or run any other command line tool you need to run here
commands = pytest
</code></pre></div></div>

<h2 id="설정">설정</h2>

<p>Tox의 동작을 보다 잘 이해하기 위해 우선 <code class="highlighter-rouge">tox.ini</code>파일의 내용을 살펴보자.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[tox]
envlist = py27,py36
install_command = pip install {opts} {packages}
</code></pre></div></div>
<p>가장 먼저 실행할 환경 목록을 기술한다. 위 설정 파일에서는 python 2.7/3.6을 지정하고 있다. 기본적으로 제공하고 있는 환경 목록은 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>py, py2, py27, py3, py34, py35, py36, py37, py38, jython, pypy, pypy2, pypy27, pypy3, pypy35
</code></pre></div></div>

<p>위의 목록 중 <code class="highlighter-rouge">py</code> 의 경우 tox를 실행한 Python version을 사용하게 된다.</p>

<p>다음으로 <code class="highlighter-rouge">[testenv]</code> 항목에는 모든 환경에서 공통적으로 실행할 설정들을 기술한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[testenv]
# python interpreter
basepython =
   py26: python2.6
   py27: python2.7
# install testing framework
# ... or install anything else you might need here
deps = pytest
# run the tests
# ... or run any other command line tool you need to run here
commands = pytest
</code></pre></div></div>

<p>다음으로 특정 환경을 지정하여 추가적으로 더할 설정들을 기술한다. 이를 위해 <code class="highlighter-rouge">[testenv:NAME]</code>와 같이 환경 이름을 지정한다. 각 필드 별로도 환경 이름이나 부분 문자열을 지정하면, tox가 매칭되는 환경을 찾아 지정한 설정을 적용한다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deps =
    pytest
    django15: Django&gt;=1.5,&lt;1.6
    django16: Django&gt;=1.6,&lt;1.7
    django17: Django&gt;=1.7,&lt;1.8
    django18: Django&gt;=1.8,&lt;1.9
    py26: unittest2
</code></pre></div></div>
<p>위의 예제는 환경 이름이 <code class="highlighter-rouge">django15</code>이거나 해당 문자열이 포함되는 경우 <code class="highlighter-rouge">Django&gt;=1.5,&lt;1.6</code>이 설치되도록 설정한 것을 보여준다.</p>

<p>설치되어야 하는 패키지가 많은 경우 <code class="highlighter-rouge">pip</code>를 사용하듯이 <code class="highlighter-rouge">requirements.txt</code>를 지정할 수 도 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deps =
    -r{toxinidir}/test-requirements.txt
</code></pre></div></div>
<p><code class="highlighter-rouge">commands</code>에는 테스트를 실행하기 위한 명령을 기술한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>commands =
    python test.py
</code></pre></div></div>

<p>기본적으로 모든 <code class="highlighter-rouge">commands</code>는 <code class="highlighter-rouge">{toxinidir}</code> 즉, <code class="highlighter-rouge">tox.ini</code>파일이 존재하는 디렉토리에서 실행된다.  이 때 작업 디렉토리를 변경하고 싶다면 <code class="highlighter-rouge">changedir</code>에 명시하면 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[testenv:docs]
changedir = docs
deps =
    sphinx
commands =
    sphinx-build -W -b html -d {envtmpdir}/doctrees . {envtmpdir}/html
basepython = python3.7
</code></pre></div></div>
<p>이 외의 다양한 설정은 공식 문서(<a href="https://tox.readthedocs.io/en/latest/config.html">https://tox.readthedocs.io/en/latest/config.html</a>)를 참고한다.</p>

<h2 id="실행-방법">실행 방법</h2>

<p>간단히 아래와 같이 실행하면 전체 테스트를 수행하게 된다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tox
</code></pre></div></div>
<p>특정 환경을 지정해서 실행할 수 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tox -e py27
</code></pre></div></div>
<p>만약 패키지 설치를 포함하여 환경을 재구성하고 싶다면 다음과 같이 실행한다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tox -r
</code></pre></div></div>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Tox_(Python_testing_wrapper)">https://en.wikipedia.org/wiki/Tox_(Python_testing_wrapper)</a></li>
  <li><a href="https://tox.readthedocs.io/en/latest/example/basic.html#a-simple-tox-ini-default-environments">https://tox.readthedocs.io/en/latest/example/basic.html#a-simple-tox-ini-default-environments</a></li>
  <li><a href="https://waprin.io/2015/05/21/introducing-tox.html">https://waprin.io/2015/05/21/introducing-tox.html</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Remote Debugging for OpenStack: cinder-api</title>
	  <link>//remote-debugging-cinder-1</link>
	  <author></author>
	  <pubDate>2020-01-31T18:00:00-06:00</pubDate>
	  <guid>//remote-debugging-cinder-1</guid>
	  <description><![CDATA[
	     <p>이 문서에서는 Cinder 원격 디버깅에 대해서 다룬다. 본격적으로 들어가기 앞서 아래 문서를 읽고 기본 구성을 갖추도록 하자.</p>

<p><a href="https://joonghyunlee.github.io/remote-debugging-nova-1">Remote Debugging for OpenStack: nova-api</a></p>

<h3 id="cinder-설정-수정">Cinder 설정 수정</h3>

<p>Cinder API 역시 단일 프로세스로 서비스를 구동할 수 있다. 우선 Cinder 서비스를 멈춰두자. Queens의 cinder-api가 Apache httpd에 연동해서 서비스하므로 Apache httpd 서비스를 내린다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop apache2.service
</code></pre></div></div>
<p>다음으로  단일 프로세스 모드로 구동하기 위해 설정(<code class="highlighter-rouge">/etc/cinder/cinder.conf</code>)을 아래와 같이 수정하자.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[DEFAULT]
osapi_volume_workers = 1
</code></pre></div></div>
<h3 id="visual-studio-code-설정">Visual Studio Code 설정</h3>

<p>Remote Explorer에 <code class="highlighter-rouge">cinder-api</code>가 구동되는 서버를 등록한다.
<img src="assets/images/openstack/cinder/Visual_Code_Remote_SSH_Cinder_01.png" alt="Remote%20Debugging%20Cinder/Visual_Code_Remote_SSH_Cinder_01.png" />
원격지 서버에 접속한 후 Cinder 소스 코드 위치를 찾아서 연다. 아래 그림의 경우 Ubuntu 서버이기 때문에 <code class="highlighter-rouge">/usr/lib/python2.7/dist-packages/cinder</code>에 있다.
<img src="assets/images/openstack/cinder/Visual_Code_Remote_SSH_Cinder_02.png" alt="Remote%20Debugging%20Cinder/Visual_Code_Remote_SSH_Cinder_02.png" />
다음으로 디버깅 프로파일을 추가하자. 단일 프로세스 모드로 구동하기 때문에 <code class="highlighter-rouge">launch</code> 타입의 프로파일을 구성할 것이다. 사이드 바에서 Debug and Run 탭(Ctrl + Shift + D)으로 이동하여 다음과 같이 프로파일을 추가하자.
<img src="assets/images/openstack/cinder/Visual_Code_Remote_SSH_Cinder_03.png" alt="Remote%20Debugging%20Cinder/Visual_Code_Remote_SSH_Cinder_03.png" /></p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Python: cinder-api"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"python"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"pythonPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin/python2"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin/cinder-wsgi"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"--port=8776"</span><span class="w">
                </span><span class="s2">"--"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"--log-dir=/var/log/cinder"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"--config-file=/etc/cinder/cinder.conf"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="s2">"env"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="s2">"CINDER_LOCALEDIR"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/lib/python2.7/dist-packages/cinder/locale"</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="s2">"console"</span><span class="p">:</span><span class="w"> </span><span class="s2">"internalConsole"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"justMyCode"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
            </span><span class="s2">"gevent"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
            </span><span class="s2">"redirectOutput"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><code class="highlighter-rouge">cinder-api</code> 서비스는 위와 같이 구성한다. <code class="highlighter-rouge">env</code> 필드는 locale 설정을 위한 환경 변수를 정의하기 위해 추가해주었다.</p>

<h3 id="cinder-api-디버깅">cinder-api 디버깅</h3>

<p>설정한 디버깅 프로파일을 실행하면 <code class="highlighter-rouge">cinder-api</code>가 실행되고 디버깅 모드로 진입한다. 관찰할 코드에 브레이크 포인트를 설정하고 프로파일을 실행해 보자. 여기서는 볼륨 목록 조회하는 API에 브레이크 포인트를 걸어보았다.
<img src="assets/images/openstack/cinder/Visual_Code_Remote_SSH_Cinder_04.png" alt="Remote%20Debugging%20Cinder/Visual_Code_Remote_SSH_Cinder_04.png" />
TERMINAL 패널을 열어 Cinder CLI를 통해 이미지 조회를 해보자. 그럼 아래과 같이 브레이크 포인트가 있는 지점에 멈추고 디버깅을 진행할 수 있다.
<img src="assets/images/openstack/cinder/Visual_Code_Remote_SSH_Cinder_05.png" alt="Remote%20Debugging%20Cinder/Visual_Code_Remote_SSH_Cinder_05.png" /></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://code.visualstudio.com/docs/python/debugging">https://code.visualstudio.com/docs/python/debugging</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Pyflame: Python CPU Profiler</title>
	  <link>//pyflame-python-profiler</link>
	  <author></author>
	  <pubDate>2020-01-19T06:00:00-06:00</pubDate>
	  <guid>//pyflame-python-profiler</guid>
	  <description><![CDATA[
	     <p>이 문서는 실행 중인 Python 어플리케이션을 프로파일링하기 위한 Pyflame에 대해 설명한다. 먼저 Pyframe을 이용한 프로파일링을 실습해보고, Pyflame의 동작 방식에 대해 알아보도록 한다.</p>

<h2 id="deterministicstatistical-프로파일링">Deterministic/Statistical 프로파일링</h2>

<p>코드 내의 모든 함수 호출/반환, 예외 발생과 같은 이벤트를 추적하여 기록하는 것을 deterministic 프로파일링이라고 한다. 대표적으로 Python에 내장된 <code class="highlighter-rouge">profile</code>, <code class="highlighter-rouge">cProfile</code> 모듈이 있다. 이러한 방식의 프로파일링은 모든 이벤트를 추적하기 때문에 정확한 결과를 얻을 수 있다는 장점이 있지만, 코드 내 모든 진행을 추적하기 위한 프로브 코드를 삽입하기 때문에 높은 오버헤드를 가지므로 절대 시간 분석에는 유용하지 않다. 또한 프로브 코드를 삽입할 수 없다면 전체 호출 스택을 기록할 수 없어 관찰할 수 있는 범위가 제한된다. 추적 기능을 활성화하기 위해 코드 수정이 필요하거나 실행 중인 프로세스를 관찰할 수 없다는 것이 단점이다.</p>

<p>이와 반대로 샘플링을 통한 프로파일링 방식을 statistical 프로파일링이라고 한다. 보통 일정한 간격으로 대상 프로세스를 멈추고 호출 스택을 기록하게 된다. 이러한 방식은 deterministic 방식처럼 모든 이벤트들을 관찰할 수는 없지만, 샘플링 주기를 조절하여 프로파일링에 드는 오버헤드를 줄일 수 있다. 그래서 좀 덜 정확한 데이터를 낮은 오버헤드를 통해 얻을 수 있게 되는 것이다. 이러한 방식의 프로파일러로는 대표적으로 Uber에서 개발한 pyflame이 있다.</p>

<p>특히 Pyflame은 코드 수정 없이 실행 중인 프로세스를 추적할 수 있도록 개발되었다. 이는 Unix 호환 시스템에서 제공하는 <code class="highlighter-rouge">ptrace</code> 시스템 콜에 의해서 가능한 것이다. 이 <code class="highlighter-rouge">ptrace</code> 시스템 콜은 특정 프로세스의 가상 메모리 영역을 읽을 수 있다. 이 <code class="highlighter-rouge">ptrace</code> 시스템 콜을 통해 어떻게 동작하는지에 대해서는 구체적으로 나중에 알아보도록 하고 우선 간단히 사용 방법에 대해서 알아보자.</p>

<h2 id="사용-방법">사용 방법</h2>

<p>Pyflame은 직접 소스 코드로부터 빌드해서 사용해야 한다. 먼저 빌드에 필요한 패키지들을 설치하자. 여기서는 Ubuntu/Debian 배포판을 기준으로 설명한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install autoconf autotools-dev g++ pkg-config python-dev
</code></pre></div></div>

<p>다음 소스 코드를 내려받아 빌드한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/uber-archive/pyflame
cd pyflame
./autogen.sh
./configure
make
make install
</code></pre></div></div>

<p>이러면 src 디렉토리 밑에 <code class="highlighter-rouge">pyflame</code> 바이너리가 생성된다. 이제 실제 프로세스를 프로파일링 해보자.</p>

<p>Pyflame를 사용하여 Python 프로세스를 프로파일링하기 위해서는 대상 프로세스의 pid를 지정해줘야 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyflame -p PID
</code></pre></div></div>

<p>이렇게 실행하면 기본값으로 1초 동안 1ms 간격으로 샘플링을 한다. 샘플링 간격 및 주기를 조정하기 위해서는 다음과 같이 추가 옵션을 준다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyflame -s 60 -r 0.01 -p PID
</code></pre></div></div>

<p><code class="highlighter-rouge">-s</code>옵션은 샘플링 간격을 의미하고, <code class="highlighter-rouge">-r</code>옵션은 샘플링 주기를 의미한다. 둘 다 단위는 초(s)이다.</p>

<p>실행하면 프로파일링 분석 결과가 화면에 출력된다. 파일에 기록하기 위해서는 <code class="highlighter-rouge">-o</code>옵션을 사용해 출력 파일을 지정한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyflame -s 60 -r 0.01 -p PID -o pyflame.out
</code></pre></div></div>

<p>분석 결과는 샘플링 기간 동안 실행되었던 코드 이력을 Flame Graph 형태로 나타낸다. 출력 결과를 Flame Graph로 변환해서 보려면 다음과 같이 실행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/brendangregg/FlameGraph
cd FlameGraph
flamegraph.pl &lt; pyflame.out &gt; GRAPH.svg
</code></pre></div></div>

<p>Flame Graph는 기본적으로 시간 정보를 포함하지 않기 때문에 변환 결과에도 timestamp가 포함되지 않는다. 또한 출력되는 그래프가 SVG 벡터 이미지이기 때문에 상세히 살펴보기에도 어려움이 있다. 보다 편하게 볼 수 있도록 Flame Chart 형태로 출력한 뒤 Chrome을 통해서 볼 수 있도록 하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyflame -flamechart -s 60 -r 0.01 -p PID -o pyflame.out
cat pyflame.out | flame-chart-json &gt; flame_chart.cpuprofile
</code></pre></div></div>

<p>Chrome 개발자 도구를 실행하여 메뉴 탭을 연 후 More tools &gt; JavaScript Profiler를 실행하면 새 메뉴가 나타난다.</p>

<p><img src="assets/images/pyflame/Chrome_CPU_Profiler.png" alt="Pyflame%20Uber%20Engineering%20s%20Ptracing%20Profiler/Chrome_CPU_Profiler.png" /></p>

<p>이 창에서 Load 버튼을 클릭하여 변환한 <code class="highlighter-rouge">cpuprofile</code> 파일을 열면 Flame Chart를 확인 할 수 있다.</p>

<p><img src="assets/images/pyflame/Chrome_CPU_Profiler_02.png" alt="Pyflame%20Uber%20Engineering%20s%20Ptracing%20Profiler/Chrome_CPU_Profiler_02.png" /></p>

<h2 id="pyflame-동작">Pyflame 동작</h2>

<p>Pyflame은 앞 서 언급한 <code class="highlighter-rouge">ptrace</code> 시스템콜을 통해 프로세스 정보를 알아온다. 이 <code class="highlighter-rouge">ptrace</code> 을 통해 Python 프로세스를 프로파일링을 하는 기본 동작은 다음과 같다.</p>

<ol>
  <li>주기적으로 대상 프로세스에 ‘attach’ 한다.</li>
  <li>대상 프로세스의 가상 메모리 영역을 읽어서 호출 스택을 얻어온다.</li>
  <li>프로세스에서 ‘detach’ 한다.</li>
</ol>

<p>매우 간단해 보이지만 중요한 것은 메모리 영역을 읽어서 Python 호출 스택을 재구성해내는 것은 간단하지 않다. 이 과정을 이해하기 위해서는 먼저 Python 인터프리터(특히 CPython)의 동작을 이해할 필요가 있다.</p>

<p>Python은 Global Interpreter Lock(GIL)의 존재로 인해 하나의 프로세스에서는 오직 하나의 스레드만 실행할 수 있다. 이러한 구조에서 여러 스레드는 다음 그림과 같이 실행된다.</p>

<p><img src="assets/images/pyflame/Pyflame_01.png" alt="Pyflame%20Uber%20Engineering%20s%20Ptracing%20Profiler/Pyflame_01.png" /></p>

<p>즉 모든 스레드가 실행되기 위해서는 GIL을 획득해야 하고, 실행이 종료되거나 IO 작업을 대기하는 경우 GIL을 반환하고 다른 스레드로 실행 흐름을 넘겨준다. 현재 실행 중인 스레드의 정보는 CPyhon인터프리터의 전역 변수인 <code class="highlighter-rouge">_PyThreadState_Current</code>에 저장되고 이를 통해 현재 스레드의 Frame 객체들을 얻어올 수 있게 된다. Python의 Frame 객체는 실행 프레임을 나타내는 것으로서 함수 호출시 내부적으로 생성된다. 각 Frame 객체는 현재 실행 중인 Python 소스 코드 파일 이름, 함수 이름, 코드 줄 수를 저장하고 있다. 이 Frame은 호출 순서대로 연결 리스트를 이루게 되므로, Frame 객체를 읽어서 호출 스택을 재구성 할 수 있게 되는 것이다.</p>

<p><img src="assets/images/pyflame/Pyflame_02.png" alt="Pyflame%20Uber%20Engineering%20s%20Ptracing%20Profiler/Pyflame_02.png" /></p>

<p>그럼 <code class="highlighter-rouge">_PyThreadState_Current</code>는 어떻게 알아올 수 있는가? 이 것은 Linux의 <code class="highlighter-rouge">proc</code> 파일 시스템을 통해 가능하다. <code class="highlighter-rouge">/proc/PID/exe</code>는 프로세스 ID가 PID인 프로세스의 executable 바이너리의 심볼릭 링크이다. 이 파일은 Executable and Linkable Format (ELF) 포맷으로 되어 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ls -l /proc/25871/exe
lrwxrwxrwx 1 nova nova 0 Dec 30 06:41 /proc/25871/exe -&gt; /usr/bin/python2.7
$ hexdump -n 16 /proc/25871/exe
0000000 457f 464c 0102 0001 0000 0000 0000 0000
</code></pre></div></div>

<p>위의 예제는 실제 Python 어플리케이션의 <code class="highlighter-rouge">exe</code> 파일 정보를 나타낸 것이다. 당연한 말이겠지만 Python 어플리케이션의 <code class="highlighter-rouge">exe</code>파일은 기본적으로 Python 인터프리터를 가리키고 있다.</p>

<p>Pyflame 개발자들은 바로 이 <code class="highlighter-rouge">exe</code>파일로 부터 <code class="highlighter-rouge">_PyThreadState_Current</code>를 얻어내기로 하였다. ELF 바이너리로부터 전역변수(정확히는 변수의 주소)를 얻어오려면 심볼 테이블을 뒤져야 한다. 이 심볼테이블은 ELF의 <code class="highlighter-rouge">.symtab</code> 또는 <code class="highlighter-rouge">.dynsym</code> 섹션에 있다. 이 섹션들은 각각 정적 또는 동적인 심볼의 정보를 갖고 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ readelf -S /proc/25871/exe
There are 28 section headers, starting at offset 0x377868:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
       00000000000028e8  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           0000000000002b80  00002b80
       0000000000009db0  0000000000000018   A       6     1     8
  [ 6] .dynstr           STRTAB           000000000000c930  0000c930
       0000000000006dcb  0000000000000000   A       0     0     1
</code></pre></div></div>

<p>앞서 예제의 섹션 정보를 나타낸 것이다. 위의 정보에서 <code class="highlighter-rouge">.dynsym</code>, <code class="highlighter-rouge">.dynstr</code> 섹션 주소를 확인할 수 있다. 이 섹션들은 아래 구조체의 배열로 표현되며, 이 배열의 원소는 각각 심볼 하나를 의미한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Elf64_Sym {
		Elf64_Word      st_name;
    unsigned char   st_info;
    unsigned char   st_other;
    Elf64_Half      st_shndx;
    Elf64_Addr      st_value;
    Elf64_Xword     st_size;
};
</code></pre></div></div>

<p>위 구조체는 Linux의 ELF 포맷의 심볼 테이블 엔트리를 나타내는 구조체이다. 코드에 있는 <code class="highlighter-rouge">st_name</code> 필드는 사실 문자열이 아니라 <code class="highlighter-rouge">.symstr</code> 또는 <code class="highlighter-rouge">.dynstr</code> 섹션의 심볼 문자열 테이블 인덱스를 포함하고 있다. 따라서 Pyflame에서는 이 테이블들을 순회하며 <code class="highlighter-rouge">_PyThreadState_Current</code>을 찾는다. 이러한 과정은 <code class="highlighter-rouge">readelf</code> 명령어의 <code class="highlighter-rouge">-s</code> 옵션을 통해 심볼들을 확인하여 간단히 따라할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ readelf -s /proc/25871/exe
Symbol table '.dynsym' contains 1682 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
   ...
   896: 0000000000578650     8 OBJECT  GLOBAL DEFAULT   25 _PyThreadState_Current
</code></pre></div></div>

<p>자 이제 <code class="highlighter-rouge">_PyThreadState_Current</code>을 찾아냈다. 이 변수는 사실 CPython의 <code class="highlighter-rouge">Include/pystate.h</code>에 정의되어 있는 <code class="highlighter-rouge">PyThreadState</code> 구조체의 배열이다. 이 배열을 읽어들여 Thread 정보를 가져온다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Variable and macro for in-line access to current thread state */

PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
...
typedef struct _ts {
    struct _ts *next;
    PyInterpreterState *interp;
    ...
    struct _frame *frame;
    long thread_id; /* Thread id where this tstate was created */
} PyThreadState;
</code></pre></div></div>

<p>우리가 주목할 구조체 멤버 변수는 <code class="highlighter-rouge">frame</code>이다. 바로 이 변수가 Frame 객체의 연결 리스트를 가리킨다. Frame 객체 구조체 정의는 <code class="highlighter-rouge">Include/frameobject.h</code>에 있으며 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _frame {
    PyObject_VAR_HEAD
    struct _frame *f_back;      /* previous frame, or NULL */
    PyCodeObject *f_code;       /* code segment */
    ...
    int f_lineno;               /* Current line number */
    ...
} PyFrameObject;
</code></pre></div></div>

<p>PyCodeObject 구조체의 정의는 <code class="highlighter-rouge">Include/code.h</code>에 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    ...
    PyObject *co_names;         /* list of strings (names used) */
    PyObject *co_varnames;      /* tuple of strings (local variable names) */
    ...
    PyObject *co_filename;      /* unicode (where it was loaded from) */
    PyObject *co_name;          /* unicode (name, for reference) */
    ...
} PyCodeObject;
</code></pre></div></div>

<p>결국 각 PyFrameObject 구조체 변수들로부터 Code와 실행 중인 라인 번호를 얻어오게 된다. 이 Frame 들을 읽어들여서 전체 호출 스택을 구성할 수 있게되는 것이다.</p>

<h2 id="총평">총평</h2>

<p>Python으로 작성된 웹서비스를 개발하는 입장에서 실행 중인 프로세스를 모니터링할 수 있는 방안을 오랫동안 찾아왔다. 그러다 우연하게 Pyframe을 접하게 되었고, 이를 통해 장애 상황에서 서비스의 문제점을 바로 찾아 해결하는 기분 좋은 경험을 하기도 했다. 개인적으로 이렇게 유용한 도구가 과연 어떻게 동작하는지 이해하고 싶었고 시간이 지났지만 지금에서라도 문서로 정리할 수 있어서 기쁘게 생각한다.</p>

<p>나에게 있어서 Uber는 단순히 택시 앱 회사에 불과했지만 이 Pyframe을 접하고 그들의 기술력에 경외감을 느낀다. 일반적으로 Python은 성능이 떨어진다고 알려져 있고 병목 구간은 다른 컴파일 언어 (보통 C/C++)로 재작성해서 대체하는 방식이 많이 알려져 있다. 우리도 Python의 떨어지는 성능을 으레 그렇거니 하면서 넘겼던 것이 사실이다. 그러나 Uber의 엔지니어는 새로운 프로파일링 도구를 만들어서 병목 구간을 분석하고 그 것을 극복하려는 노력을 해왔던 것 같다. 그들의 의지와 역량에 찬사를 보내며 이 글을 마친다.</p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://github.com/uber-archive/pyflame">https://github.com/uber-archive/pyflame</a></li>
  <li><a href="https://eng.uber.com/pyflame/">https://eng.uber.com/pyflame/</a></li>
  <li><a href="https://benbernardblog.com/using-ubers-pyflame-and-logs-to-tackle-scaling-issues/">https://benbernardblog.com/using-ubers-pyflame-and-logs-to-tackle-scaling-issues/</a></li>
  <li><a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">http://www.dabeaz.com/python/UnderstandingGIL.pdf</a></li>
  <li><a href="https://github.com/python/cpython">https://github.com/python/cpython</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Remote Debugging for OpenStack: glance-api</title>
	  <link>//remote-debugging-glance</link>
	  <author></author>
	  <pubDate>2020-01-12T06:00:00-06:00</pubDate>
	  <guid>//remote-debugging-glance</guid>
	  <description><![CDATA[
	     <p>이 문서에서는 Glance 원격 디버깅에 대해서 다룬다. 본격적으로 들어가기 앞서 아래 문서를 읽고 기본 구성을 갖추도록 하자.</p>

<h2 id="glance-설정-수정">Glance 설정 수정</h2>

<p>Glance API의 경우 다행히 단일 프로세스로 서비스를 구동할 수 있다. 우선 Glance 서비스를 멈춰두자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop glance-api.service
</code></pre></div></div>

<p>다음으로  단일 프로세스 모드로 구동하기 위해 설정(<code class="highlighter-rouge">/etc/glance/glance-api.conf</code>)을 아래와 같이 수정하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[DEFAULT]
workers = 0
</code></pre></div></div>

<p>이로써 Glance 설정은 모두 끝났다. Nova에 비해서 정말 간단하지 않은가?</p>

<h2 id="visual-studio-code-설정">Visual Studio Code 설정</h2>

<p>Nova의 원격 디버깅 과정처럼 Remote Explorer에 <code class="highlighter-rouge">glance-api</code>가 구동되는 서버를 등록한다.</p>

<p><img src="assets/images/openstack/glance/Visual_Code_Remote_SSH_Glance_01.png" alt="Remote%20Debugging%20Glance/Visual_Code_Remote_SSH_Glance_01.png" /></p>

<p>원격지 서버에 접속한 후 Glance 소스 코드 위치를 찾아서 연다. 아래 그림의 경우 Ubuntu 서버이기 때문에 <code class="highlighter-rouge">/usr/lib/python2.7/dist-packages/glance</code>에 있다.</p>

<p><img src="assets/images/openstack/glance/Visual_Code_Remote_SSH_Glance_02.png" alt="Remote%20Debugging%20Glance/Visual_Code_Remote_SSH_Glance_02.png" /></p>

<p>다음으로 디버깅 프로파일을 추가하자. 단일 프로세스 모드로 구동하기 때문에 Nova와는 달리 <code class="highlighter-rouge">launch</code> 타입의 프로파일을 구성할 것이다. 사이드 바에서 Debug and Run 탭(Ctrl + Shift + D)으로 이동하여 다음과 같이 프로파일을 추가하자.</p>

<p><img src="assets/images/openstack/glance/Visual_Code_Remote_SSH_Glance_03.png" alt="Remote%20Debugging%20Glance/Visual_Code_Remote_SSH_Glance_03.png" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: glance-api",
            "type": "python",
            "request": "launch",
            "pythonPath": "/usr/bin/python2",
            "program": "/usr/bin/glance-api",
            "args": [
                "--config-file=/etc/glance/glance-api.conf",
                "--log-file=/var/log/glance/glance-api.log",
            ],
            "console": "internalConsole",
            "justMyCode": false,
            "gevent": true,
            "redirectOutput": true
        }
    ]
}
</code></pre></div></div>

<p>Visual Studio Code가 바로 <code class="highlighter-rouge">glance-api</code> 서비스를 구동할 수 있도록 python 경로와 <code class="highlighter-rouge">glance-api</code> 경로를 추가한다. 그리고 <code class="highlighter-rouge">request</code> 필드의 값을 <code class="highlighter-rouge">launch</code>으로 해서 Visual Studio Code에서 <code class="highlighter-rouge">glance-api</code>를 직접 실행하여 디버깅하도록 한다. 또한 <code class="highlighter-rouge">gevent</code> 필드를 <code class="highlighter-rouge">true</code>로 해야 정상적으로 디버깅을 수행할 수 있다.</p>

<h2 id="glance-api-디버깅">glance-api 디버깅</h2>

<p>이제 모든 준비가 끝났다. 위에서 설정한 디버깅 프로파일을 실행하면 <code class="highlighter-rouge">glance-api</code>가 구동된다. 관찰할 코드에 브레이크 포인트를 설정하고 프로파일을 실행해 보자. 여기서는 이미지 목록 조회하는 API에 브레이크 포인트를 걸어보았다.</p>

<p><img src="assets/images/openstack/glance/Visual_Code_Remote_SSH_Glance_04.png" alt="Remote%20Debugging%20Glance/Visual_Code_Remote_SSH_Glance_04.png" /></p>

<p>TERMINAL 패널을 열어 Glance CLI를 통해 이미지 조회를 해보자. 그럼 아래과 같이 브레이크 포인트가 있는 지점에 멈추고 디버깅을 진행할 수 있다.</p>

<p><img src="assets/images/openstack/glance/Visual_Code_Remote_SSH_Glance_05.png" alt="Remote%20Debugging%20Glance/Visual_Code_Remote_SSH_Glance_05.png" /></p>

<h2 id="참고-자료">참고 자료</h2>

<ul>
  <li><a href="https://code.visualstudio.com/docs/python/debugging">https://code.visualstudio.com/docs/python/debugging</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Remote Debugging for OpenStack: nova-api</title>
	  <link>//remote-debugging-nova-1</link>
	  <author></author>
	  <pubDate>2020-01-12T06:00:00-06:00</pubDate>
	  <guid>//remote-debugging-nova-1</guid>
	  <description><![CDATA[
	     <p>이 문서에서는 OpenStack 개발시 필요한 디버깅 방법에 대해 다룬다. 특히 라이선스 구매가 필요한 Pycharm 대신 공개 소프트웨어인 Visual Studio Code를 통해 Queens 버전 OpenStack 디버깅하는 방법을 다룬다.</p>

<h2 id="visual-studio-code을-이용한-원격-개발">Visual Studio Code을 이용한 원격 개발</h2>

<p>Visual Studio Code를 통해 원격 호스트, 컨테이너 심지어는 WSL (Windows Subsystem for Linux)에서의 개발을 할 수 있다. 이를 통해 실제 서비스가 구동되는 원격 호스트와 다른 환경에서도 충분히 개발을 할 수 있는 것이다.</p>

<p>OpenStack을 디버깅하는 경우 이러한 원격 개발 기능은 절실히 요구된다. OpenStack은 수 많은 에이전트들과 서비스들을 통해 구성되는데, 이 많은 프로세스를 로컬 호스트에서 모두 구동하는 것은 리소스 낭비이기 때문이다. 그래서 보통 원격 서버들에 OpenStack을 구축해두고 특정 프로세스를 대상으로 디버깅을 하는 경우가 많다. 이 문서에는 Remote-SSH 확장 기능을 통해 원격 호스트에 SSH로 접근하여 디버깅하는 방법에 대해 다룬다.</p>

<h2 id="환경-설정">환경 설정</h2>

<h3 id="로컬-pc">로컬 PC</h3>

<p>당연히 로컬 PC에는 Visual Studio Code가 설치되어야 한다. <a href="https://code.visualstudio.com/Download">공식 홈페이지</a>에서 PC의 OS에 맞는 버전을 내려받아 설치하도록 하자. Visual Studio Code는 멀티 플랫폼을 지원하는 electron 기반으로 개발되었기 때문에 Windows, Mac 뿐만 아니라 Linux 배포판들도 지원한다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_Debugging_-_Download_Visual_Code.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_Debugging_-_Download_Visual_Code.png" /></p>

<p>Visual Code가 설치되면 Python 및 Remote-SSH 확장 기능을 설치한다. 사이드 바의 마켓플레이스 아이콘을 선택하여 확장 기능 뷰를 열어 Remote - SSH를 검색한 다음 설치하자. 개발자가 Microsoft로 등록된 공식 확장 기능을 찾아 설치해야 한다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_Debugging_-_Install_Remote_-_SSH_Extension.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_Debugging_-_Install_Remote_-_SSH_Extension.png" /></p>

<p>Visual Code Remote Debugging - Install Remote - SSH Extension</p>

<p>Remote - SSH 확장 기능을 설치 하면 사이드 바에 Remote Explorer 아이콘이 생긴다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_04.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_04.png" /></p>

<p>설치한 Remote - SSH 확장 기능을 이용하기 위해서는 로컬 PC에 SSH 클라이언트가 설치되어야 한다. Mac 이나 Linux의 경우 기본적으로 SSH 클라이언트가 설치되어 있어 따로 설치할 필요는 없다. 그러나 Windows의 경우 따로 설치가 필요하다. 설정 &gt; 앱 &gt; 앱 및 기능 으로 이동하여 “선택적 기능”을 선택한다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_Debugging_-_Install_SSH_Client_on_Windows.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_Debugging_-_Install_SSH_Client_on_Windows.png" /></p>

<p>그런 다음 “기능 추가”를 선택하여 “OpenSSH 클라이언트”를 설치하자.</p>

<p>간단히 PowerShell로도 설치할 수 있다. PowerShell을 관리자 권한으로 실행하여 아래 명령어를 실행한다. 자세한 설명은 Microsoft의 공식 문서 <a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Installation of OpenSSH for Windows Server 2019 and Windows 10</a> 를 참고하라.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS C:\WINDOWS\system32&gt; Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
</code></pre></div></div>

<p>원격지 호스트에 로그인하기 위해 SSH Key 파일을 생성한다. 생성 중에 passpharse와 Key 파일 저장 경로를 물어보는데, 기본 값을 선택해도 무방하다. SSH Key 파일 위치만 기억해두자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS C:\WINDOWS\system32&gt; ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (C:\Users\joonghyunlee/.ssh/id_rsa):
</code></pre></div></div>

<h3 id="원격지-호스트">원격지 호스트</h3>

<p>이제 원격지 호스트 쪽에서 접근 허용 설정을 해주도록 하자. 여기서는 <code class="highlighter-rouge">root</code> 계정으로 접근하는 것을 가정하여 설명한다. 우선 Root 계정으로 SSH 설정을 할 수 있도록 sshd 설정을 변경한다.  <code class="highlighter-rouge">/etc/ssh/sshd_config</code> 파일에서 아래 항목을 추가하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PermitRootLogin yes
</code></pre></div></div>

<p>이후 sshd 서비스를 재시작하여 설정을 반영한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart ssh.service
</code></pre></div></div>

<p>다음 로컬에서 생성한 public 키 파일(기본 값은 <code class="highlighter-rouge">id_rsa.pub</code>)을 원격지 서버로 복사하자. FileZilla와 같은 SFTP 도구를 사용해도 되지만 내용을 복사해서 붙여넣기 해도 된다. 다만 복사하는 위치는 <code class="highlighter-rouge">/root/.ssh/authorized_keys</code>이어야 한다. 여기까지 준비가 되면 이제 원격지 호스트에 접속할 수 있는 상태가 된다.</p>

<p>마지막으로 Visual Studio Code에서 디버깅을 위해 사용하는 ptvsd 모듈을 설치하자. 기본적으로 Visual Studio Code에서 Python 원격 디버깅을 위해 대상 코드에 디버깅용 코드를 삽입하여 디버깅용 서버를 띄우고 로컬 PC의 Code에서 접근하여 모니터링 및 제어하게 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install ptvsd
</code></pre></div></div>

<h2 id="visual-studio-code-설정">Visual Studio Code 설정</h2>

<p>이제 원격지 호스트를 등록하자. Visual Studio Code를 실행한 후 사이드 바에서 Remote Explorer를 선택한다. 다음 “+” 아이콘을 선택하여 SSH host 등록 창을 연다. 또는 Command Palette (<code class="highlighter-rouge">F1</code>)을 통해 “<strong>Remote SSH: Connect to Host…</strong>“를 선택해도 된다. 등록 창이 뜨면 원격지 서버 접근 계정과 호스트명을 적어주자.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_03.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_03.png" /></p>

<p>만약 SSH 관련해서 추가로 해야 하는 설정이 있다면 Remote Explorer의 SSH TARGETS 바에서 톱니바퀴 아이콘을 선택한다. 그리고 SSH 관련 설정이 저장될 폴더 위치를 물어보는데 기본값을 선택하자. 그럼 아래와 같이 설정할 수 있다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_05.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_05.png" /></p>

<p>여기서는 SSH 접근 포트를 10022로 설정했기 때문에, 따로 SSH 접속 포트만 변경해서 등록해주었다.</p>

<p>모든 과정을 마치고 정상적으로 등록이 되면 원격지 서버에 접속한 후 VS Code Server 초기화 과정을 거친다. 모든 과정이 완료되면 Visual Studio Code 좌측 하단에 접속한 서버명이 나타난다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_07.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_07.png" /></p>

<p>이 상태에서 File &gt; Open… 을 선택하면 아래와 같이 원격지 서버의 계정 홈 폴더가 나타난다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_08.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_08.png" /></p>

<p>여기서는 OpenStack Nova에 대한 디버깅을 하는 것이 목적이므로 Nova 폴더를 찾아서 열도록 하자. 아래와 같이 원격 서버에 설치된 Nova Python 패키지 경로를 찾아서 열도록 하자. 아래 그림에서 연결한 서버는 Ubuntu 18.04가 설치되어 있으므로 Nova 패키지는 <code class="highlighter-rouge">/usr/lib/python2.7/dist-packages/nova</code>에 있다. CentOS의 경우는  <code class="highlighter-rouge">/usr/lib/python2.7/site-packages/nova</code>에 있다.</p>

<p>이제 Visual Studio Code의 디버깅 프로파일을 추가해야 한다. <code class="highlighter-rouge">launch.json</code> 파일을 열어 아래 그림과 같이 디버깅 프로파일을 추가한다. Visual Studio Code의 원격 디버깅 설정은 크게 두 가지로 나뉜다. 첫 번째는 원격지 호스트에서 직접 Python 인터프리터를 실행하는 <code class="highlighter-rouge">launch</code> 방식이고, 두 번째는 소스 코드에 디버깅용 서버를 띄우는 코드를 삽입하여, 이 서버에 붙는 <code class="highlighter-rouge">attach</code> 방식이다. <code class="highlighter-rouge">launch</code> 방식이 보다 직관적이고 간편하지만 WSGI application과 같이 별도 worker 프로세스를 띄우는 경우는 <code class="highlighter-rouge">attach</code> 방식을 써야 한다.</p>

<p>여기서는 <code class="highlighter-rouge">nova-api</code>를 디버깅 하기 때문에 <code class="highlighter-rouge">attach</code>타입을 선택해야 한다. 이는 <code class="highlighter-rouge">nova-api</code> 서비스가 메인 프로세스에서 최소 1 개 이상의 자식 프로세스를 생성하여 구동하기 때문이다. 실제로 <code class="highlighter-rouge">launch</code>타입으로 <code class="highlighter-rouge">nova-api</code> 서비스를 디버깅할 경우, 오직 메인 프로세스의 내용만 접근 가능하다. (메인 프로세스의 역할은 자식 프로세스를 띄우는 것에 불과하므로 유용한 정보는 거의 없다.)</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_10.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_10.png" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: nova-api (Attach)",
            "type": "python",
            "request": "attach",
            "port": 5678,
            "host": "localhost",
            "pathMappings": [
                {
                    "localRoot": "${workspaceFolder}",
                    "remoteRoot": "${workspaceFolder}"
                }
            ],
            "redirectOutput": true,
            "justMyCode": false
        }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">attach</code>타입의 디버깅 방식은 원격 서버의 서비스와 동일한 코드를 로컬에 두고 이를 토대로 디버깅을 진행한다. 그러나 코드가 매번 변경되는 경우 로컬/원격 사이의 코드 동기화를 지속적으로 해주어야 하는 번거로움이 있다. 우리는 Visual Studio Code의 Remote-SSH 기능을 사용하여 사실상 원격지 서버에 Visual Studio Code를 띄워서 하는 것과 동일한 구성을 사용하게 된다. 따라서 로컬에서 (사실은 원격지 서버를 의미) 바로 디버깅 서버로 붙는 구성을 사용한다. 이를 위해 <code class="highlighter-rouge">host</code>, <code class="highlighter-rouge">pathMappings</code> 필드를 위와 같이 설정하는 것이다.</p>

<h2 id="nova-변경">Nova 변경</h2>

<p>Nova 서비스를 Visual Studio Code를 통해 디버깅하기 위해서는 몇 가지 설정 및 코드가 변경되어야 한다. 우선 원격지 서버에서 <code class="highlighter-rouge">nova-api</code> 서비스를 내리자. 원격 디버깅을 하려면 새로 띄워야 한다. 어떤 설정 및 코드가 변경되어야 하고 왜 바뀌어야 하는지 차차 설명하도록 하겠다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop nova-api.service
</code></pre></div></div>

<p>기본적으로 Nova에서 지원하는 원격 디버깅은 pydev를 사용해야 한다. Visual Studio Code를 사용하여 원격 디버깅을 할 수 있도록 ptvsd를 사용하여 디버깅용 서비스를 띄우는 코드를 추가해야 한다. 이 코드는 <code class="highlighter-rouge">nova/debugger.py</code>에 있다. 다음과 같이 변경하도록 하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 기존 코드는 주석 처리한다.
# try:
#     from pydev import pydevd
# except ImportError:
#     import pydevd

import ptvsd
ptvsd.enable_attach(
    address=(CONF.remote_debug.host, CONF.remote_debug.port),
    log_dir='/var/log/nova')
</code></pre></div></div>

<p>수정한 <code class="highlighter-rouge">debugger</code> 모듈이 서비스가 로드될때 초기화될 수 있도록 서비스 초기화 루틴을 수정한다. 기본적으로 Nova의 서비스는 크게 <code class="highlighter-rouge">nova/service.py</code>에 정의된 <code class="highlighter-rouge">Service</code> 클래스와 <code class="highlighter-rouge">WSGIService</code> 클래스를 사용하여 구현되었다. <code class="highlighter-rouge">nova-conductor</code>, <code class="highlighter-rouge">nova-scheduler</code> 와 같이 RPC 기반 서비스는 <code class="highlighter-rouge">Service</code> 를 사용하고 <code class="highlighter-rouge">nova-api</code>와 같은 서비스들은 <code class="highlighter-rouge">WSGIService</code> 클래스를 사용한다. 그러나 안타깝게도 <code class="highlighter-rouge">WSGIService</code> 클래스에는 <code class="highlighter-rouge">debugger</code>가 삽입되어있지 않다. 아래와 같이 추가해주도록 하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class WSGIService(service.Service):
    """Provides ability to launch API from a 'paste' configuration."""
    ...
    def start(self):
        ...
        self.server.start()
        if self.manager:
            self.manager.post_start_hook()

        # 마지막에 debugger 초기화 코드를 삽입한다.
        debugger.init()
</code></pre></div></div>

<p>원격 디버깅을 용이하게 하기 위해 <code class="highlighter-rouge">nova-api</code>서비스의 프로세스 갯수를 제한해야 한다. <code class="highlighter-rouge">/etc/nova/nova.conf</code>에서 아래 설정을 추가하여 worker 프로세스 갯수를 1개로 바꾼다. 바꾸지 않으면 여러 개의 ptvsd 서버가 구동되려 시도하고 포트 바인딩 에러가 발생한다. 애초에 멀티 프로세스 환경에서 이런 식의 원격 디버깅을 할 수 없다. 다음과 같이 설정을 추가하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[DEFAULT]
enabled_apis = osapi_compute
osapi_compute_workers = 1
...
[remote_debug]
host = 0.0.0.0
port = 5678
</code></pre></div></div>

<p>이제 모든 준비가 끝났다. 아래의 커맨드를 실행하여 <code class="highlighter-rouge">nova-api</code>서비스를 띄우자. 서비스를 띄우면 삽입한 코드에 따라 ptvsd 디버깅 서버도 같이 구동된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runuser -l nova -c '/usr/bin/python2 /usr/bin/nova-api \
		--config-file=/etc/nova/nova.conf \
		--log-file=/var/log/nova/nova-api.log \
		--remote_debug-host 0.0.0.0 --remote_debug-port 5678'
</code></pre></div></div>

<p>위의 명령어를 보면 <code class="highlighter-rouge">--remote_debug-host</code>, <code class="highlighter-rouge">--remote_debug-port</code> 옵션을 추가한 것을 알수 있다. Nova 코드에서 이 옵션의 유무를 기준으로 eventlet의 thread patching 기능을 활성하하기 때문에 반드시 추가해줘야 한다.</p>

<h2 id="nova-api-디버깅">nova-api 디버깅</h2>

<p>앞 서 설정한 디버깅 프로파일을 실행하여 원격지 서버의 ptvsd 서버로 붙도록 하자. 사이드 바의 DEBUG AND RUN 아이콘을 선택하여 프로파일을 실행한다. 정상적으로 실행되면 하단 라인의 색이 주황색으로 바뀌고, 상단에 디버깅용 아이콘 패널이 나타난다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_11.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_11.png" /></p>

<p>이제 원하는 코드를 열고 브레이크 포인트를 걸어보자. 그리고 해당 브레이크 포인트로 진입하는 API 호출 또는 명령어를 실행한다. 여기서는 Flavor 상세 조회에 브레이크 포인트를 걸고 Flavor 조회를 실행한다. 그러면 아래와 같이 브레이크 포인트 지점에서 멈추고 변수 보기, 코드 실행 등을 수행할 수 있다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_12.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_12.png" /></p>

<p>디버깅을 마치고 원격지 서버와의 접근을 끊기 위해서는 좌측 하단의 “SSH:…“를 클릭하여 Remote-SSH 메뉴를 연다. 메뉴의 마지막 항목인 Close Remote Connection 을 선택하면 서버와의 접속이 종료된다.</p>

<p><img src="assets/images/openstack/nova/Visual_Code_Remote_SSH_13.png" alt="Remote%20Debugging%20Nova%201/Visual_Code_Remote_SSH_13.png" /></p>

<h2 id="참고-문서">참고 문서</h2>

<ul>
  <li>https://code.visualstudio.com/docs/remote/ssh</li>
  <li>https://code.visualstudio.com/blogs/2019/10/03/remote-ssh-tips-and-tricks</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
